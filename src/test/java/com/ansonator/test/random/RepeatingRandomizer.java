package com.ansonator.test.random;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.function.Function;
import java.util.function.Supplier;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jeasy.random.randomizers.FakerBasedRandomizer;

import com.github.javafaker.Faker;
import com.google.common.collect.ImmutableList;

/**
 * Maintains a cache in memory of all randomly generated objects in order to limit the set of distinct objects that may be created. By
 * default, it will re-generate an object until it has something distinct from all objects previously generated by this Randomizer. Provides
 * method {@link #getAll} for retrieving the full set of distinct objects that can be generated.
 * 
 * @author BA030483
 *
 * @param <T>
 */
public abstract class RepeatingRandomizer<T> extends FakerBasedRandomizer<T> implements Supplier<T> {
    protected static final Logger LOGGER = LogManager.getLogger();
    private static final int MAX_DISTINCT_ATTEMPTS = 100;

    private String name = null;
    private int maxSize;
    private final boolean filterDuplicates = true;
    private final ArrayList<T> populatedBeans;
    private Function<Integer, Integer> chooser;
    private long totalGenerated = 0;

    protected RepeatingRandomizer() {
        this(1);
    }

    /**
     * @param maxSize the maximum number of distinct objects that this Randomizer can generate.
     */
    protected RepeatingRandomizer(int maxSize) {
        super(0);
        this.maxSize = maxSize;
        populatedBeans = new ArrayList<>(maxSize);
        setChooser(size -> random.nextInt(size));
    }

    /**
     * Used to influence how objects are selected from the pool of previously generated objects. For example, you might want a non-uniform
     * distribution.
     * 
     * @param chooser a Function which accepts the current max size for this randomizer and outputs an integer in the range [0, maxSize).
     */
    public void setChooser(Function<Integer, Integer> chooser) {
        this.chooser = chooser;
    }

    /**
     * Generates a name when one has not been provided by {@link #setName}.
     * 
     * @return a name
     */
    protected String autoName() {
        return getClass().getSimpleName() + maxSize;
    }

    /**
     * Identifies this Randomizer.
     * 
     * @return this randomizer instance's name
     */
    public String getName() {
        if (name == null) {
            name = autoName();
        }
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return getName();
    }

    /**
     * Increases or decreases the number of distinct values this randomizer will retain.
     * 
     * @param size
     */
    public void setMaxSize(int size) {
        if (size < populatedBeans.size()) {
            for (T obj : populatedBeans.subList(size, populatedBeans.size())) {
                populatedBeans.remove(obj);
            }
        }
        else {
            populatedBeans.ensureCapacity(size);
        }
        maxSize = size;
    }

    /**
     * @returns the number of distinct values this randomizer will retain.
     */
    public int getMaxSize() {
        return maxSize;
    }

    @Override
    public final T getRandomValue() {
        T result;
        int index = chooser.apply(maxSize);
        if (index < 0 || index >= maxSize) {
            throw new IndexOutOfBoundsException("Chooser must return values in range [0," + maxSize + ")");
        }
        if (index >= populatedBeans.size()) {
            result = get();
            long duplicatesFiltered = 0;
            while (filterDuplicates && populatedBeans.contains(result)) {
                duplicatesFiltered++;
                if (duplicatesFiltered > MAX_DISTINCT_ATTEMPTS) {
                    throw new IllegalStateException(
                        String.format("%s generated %d duplicates in a row.  Is it able to generate %d distinct values?",
                            getClass().getSimpleName(), duplicatesFiltered, maxSize));
                }
                result = get();
            }
            index = populatedBeans.size();
            populatedBeans.add(result);
        } else {
            result = populatedBeans.get(index);
        }
        assert (result != null);
        if (LOGGER.isTraceEnabled()) {
            totalGenerated++;
            if (totalGenerated % 10000 == 0) {
                LOGGER.trace("{}: size = {} / {}, retrieved = {}", getClass().getSimpleName(), populatedBeans.size(), maxSize,
                    totalGenerated);
            }
        }
        return result;
    }

    public List<T> getAll() {
        while (populatedBeans.size() < maxSize) {
            populatedBeans.add(get());
        }
        return ImmutableList.copyOf(populatedBeans);
    }

    public static <T> RepeatingRandomizer<T> create(int poolSize, Supplier<T> randomizer) {
        return new RepeatingRandomizer<T>(poolSize) {
            @Override
            public T get() {
                return randomizer.get();
            }
        };
    }

    public static <T> RepeatingRandomizer<T> createFromFaker(int poolSize, Function<Faker, T> randomizer) {
        return new RepeatingRandomizer<T>(poolSize) {
            @Override
            public T get() {
                return randomizer.apply(faker);
            }
        };
    }

    public static <T> RepeatingRandomizer<T> createFromRandom(int poolSize, Function<Random, T> randomizer) {
        return new RepeatingRandomizer<T>(poolSize) {
            @Override
            public T get() {
                return randomizer.apply(random);
            }
        };
    }
}
